// Copyright Thibault Lambert

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http ://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// needs to before Common.usf
#define SHADOW_DEPTH_SHADER 1
#define USE_STENCIL_LOD_DITHER	0

#include "/Engine/Private/Common.ush"

// Reroute SceneTexturesStruct uniform buffer references to the shadow depth pass uniform buffer
#define PassStruct ShadowDepthPass
#define SceneTexturesStruct ShadowDepthPass.SceneTextures 

#include "/Engine/Generated/Material.ush"
#include "/Engine/Generated/VertexFactory.ush"
#include "/Engine/Private/ShadowDepthCommon.ush"

#if VIRTUAL_SM_ENABLED
	#include "/Engine/Private/Nanite/NaniteDataDecode.ush"
	#include "/Engine/Private/SceneData.ush"
	#include "/Engine/Private/VirtualShadowMaps/VirtualShadowMapPageAccessCommon.ush"
#endif

#define SECONDARY_OCCLUSION			1

int4 CustomIntData0;
int4 CustomIntData1;
float4 CustomFloatData0;
float4 CustomFloatData1;
float4 CustomFloatData2;
StructuredBuffer<uint> DensityVdbBuffer;
StructuredBuffer<uint> TemperatureVdbBuffer;
StructuredBuffer<uint> ColorVdbBuffer;
Texture2D BlackbodyColor; // curve atlas

// I can't make a custom MaterialExpression from a plugin. 
// It's far from ideal but I have to adapt and use a 
// mix of material params, and component params.
#define MAX_NUM_STEPS uint(CustomIntData0.x)
#define SAMPLES_PER_PIXEL uint(CustomIntData0.y)
#define SAMPLES_PER_PIXEL_FLOAT float(CustomIntData0.y)
#define COLORED_TRANSMITTANCE bool(CustomIntData0.z) 
#define TEMPORAL_NOISE bool(CustomIntData0.w) 
#define CURVE_INDEX CustomIntData1.x
#define CURVE_HEIGHT CustomIntData1.y
#define TRANSLUCENT_LEVEL_SET CustomIntData1.z
#define LOCAL_STEP_SIZE CustomFloatData0.x
#define SHADOW_STEP_SIZE_MULT CustomFloatData0.y
#define VOXEL_SIZE CustomFloatData0.z
#define JITTER_MULT 0.0 // force no jittering
#define ANISOTROPY CustomFloatData1.x
#define ALBEDO CustomFloatData1.y
#define BLACKBODY_INTENSITY CustomFloatData1.z
#define BLACKBODY_TEMPERATURE CustomFloatData1.w
#define DENSITY_MULT CustomFloatData2.x
#define VOLUME_PADDING CustomFloatData2.y
#define AMBIENT CustomFloatData2.z
#define SHADOW_THRESHOLD CustomFloatData2.w

#define SAMPLING_FLOAT ReadValue
#define SAMPLING_VECTOR ReadValueVec3f
#if USE_TRILINEAR_SAMPLING
	#define SAMPLING_FLOAT_FILTERING TrilinearSampling
	#define SAMPLING_VECTOR_FILTERING TrilinearSamplingVec3f
#else
	#define SAMPLING_FLOAT_FILTERING SAMPLING_FLOAT
	#define SAMPLING_VECTOR_FILTERING SAMPLING_VECTOR
#endif

#include "/Plugin/VdbVolume/Private/VdbCommon.ush"
#include "/Plugin/VdbVolume/Private/VdbRaymarchingUtils.ush"

void SetShadowDepthOutputs(
	float4x4 WorldToClipMatrix,
	float4x4 WorldToShadowMatrix,
	float4 WorldPosition,
	float3 WorldVertexNormal,
	out float4 OutPosition,
	out float ShadowDepth
#if PERSPECTIVE_CORRECT_DEPTH
	, out float OutDepthBias
#endif
)
{
	OutPosition = mul(WorldPosition, WorldToClipMatrix);

	// Clamp the vertex to the near plane if it is in front of the near plane
	// This has problems if some vertices of a triangle get clamped and others do not, also causes artifacts with non-ortho projections
	if (PassStruct.bClampToNearPlane > 0 && OutPosition.z > OutPosition.w)
	{
		OutPosition.z = 0.999999f;
		OutPosition.w = 1.0f;
	}

#if ONEPASS_POINTLIGHT_SHADOW
	const float3 ViewDirection = -normalize(mul(WorldPosition, WorldToShadowMatrix).xyz);
	const float3 ViewNormal = mul(float4(WorldVertexNormal,0), WorldToShadowMatrix).xyz;
	const float NoL = abs(dot(ViewDirection, ViewNormal));
#else
	const float NoL = abs(dot(
		float3(WorldToShadowMatrix[0].z, WorldToShadowMatrix[1].z, WorldToShadowMatrix[2].z),
		WorldVertexNormal));
#endif

	const float MaxSlopeDepthBias = PassStruct.ShadowParams.z;
	const float Slope = clamp(abs(NoL) > 0 ? sqrt(saturate(1 - NoL * NoL)) / NoL : MaxSlopeDepthBias, 0, MaxSlopeDepthBias);
	
	const float SlopeDepthBias = PassStruct.ShadowParams.y;
	const float SlopeBias = SlopeDepthBias * Slope;

	const float ConstantDepthBias = PassStruct.ShadowParams.x;
	const float DepthBias = SlopeBias + ConstantDepthBias;

#if PERSPECTIVE_CORRECT_DEPTH
		ShadowDepth = OutPosition.z;
		OutDepthBias = DepthBias;
#elif ONEPASS_POINTLIGHT_SHADOW
		ShadowDepth = 0;
		//OutPosition.z += DepthBias;
#else
		// Output linear, normalized depth
	const float InvMaxSubjectDepth = PassStruct.ShadowParams.w;
	#if PLATFORM_NEEDS_PRECISE_SHADOW_DEPTH
		precise 
	#endif
	float AdjustedDepth = (1 - OutPosition.z * InvMaxSubjectDepth) + DepthBias;
	ShadowDepth = AdjustedDepth;
	OutPosition.z = AdjustedDepth;
#endif
}

VdbRay PrepareShadowRayFromPixel(pnanovdb_buf_t grid_buf, pnanovdb_grid_handle_t grid, float4 SvPosition, float4x4 WorldToLocal, float DeviceZ, bool Forward)
{
	float4 ClipPosition = SvPositionToScreenPosition(SvPosition) / SvPosition.w; // NDC to Clip

	float4 Near = mul(float4(ClipPosition.xy, NearDepthValue, 1.0), VdbDepthParams.ShadowClipToTranslatedWorld); // near (world space)
	float4 Far = mul(float4(ClipPosition.xy, DeviceZ, 1.0), VdbDepthParams.ShadowClipToTranslatedWorld); // scene gbuffer (world space)

	float3 Start = Near.xyz / Near.w;
	Start -= LWCHackToFloat(VdbDepthParams.ShadowPreViewTranslation);
	float3 Stop = Far.xyz / Far.w;
	Stop -= LWCHackToFloat(VdbDepthParams.ShadowPreViewTranslation);

	// Index space
	float3 Origin = WorldToIndexPosition(Start, WorldToLocal, grid_buf, grid);
	float3 End = WorldToIndexPosition(Stop, WorldToLocal, grid_buf, grid);

	float Dist = length(End - Origin);

	VdbRay Ray;
	if (Forward)
	{
		Ray.Origin = Origin;
		Ray.Direction = (End - Origin) / Dist;
	}
	else
	{
		Ray.Origin = End;
		Ray.Direction = (Origin - End) / Dist;
	}
	Ray.TMin = 0.0001f;
	Ray.TMax = POSITIVE_INFINITY;

	return Ray;
}

//-----------------------------------------------------------------------------------------------------------
#if VERTEXSHADER
//-----------------------------------------------------------------------------------------------------------

void MainVS(
	FVertexFactoryInput Input,
	#if ONEPASS_POINTLIGHT_SHADOW
		out uint LayerIndex : SV_RenderTargetArrayIndex,
	#endif
	out FShadowDepthVSToPS OutParameters,

	#if VIRTUAL_SM_ENABLED
		out nointerpolation uint PackedPageInfo : TEXCOORD8,
	#endif
	out float4 OutPosition : SV_POSITION
	#if VIRTUAL_SM_ENABLED	
		// OLA-TODO: this collides with instanced stereo, which thankfully is not used with shadow maps, so should be fine, presumably.
		, out float4 OutVirtualSmPageClip : SV_ClipDistance
	#endif // VIRTUAL_SM_ENABLED
	)
{
	ResolvedView = ResolveView();

	FVertexFactoryIntermediates VFIntermediates = GetVertexFactoryIntermediates(Input);
	float4 WorldPos = VertexFactoryGetWorldPosition(Input, VFIntermediates);
	float3x3 TangentToLocal = VertexFactoryGetTangentToLocal(Input, VFIntermediates);
	FMaterialVertexParameters VertexParameters = GetMaterialVertexParameters(Input, VFIntermediates, WorldPos.xyz, TangentToLocal);
	const float3 WorldNormal = VertexFactoryGetWorldNormal(Input, VFIntermediates);

	#if ONEPASS_POINTLIGHT_SHADOW
		OutPosition = WorldPos;

		#if INTERPOLATE_VF_ATTRIBUTES
			// Masked materials need texture coords to clip
			OutParameters.FactoryInterpolants = VertexFactoryGetInterpolantsVSToPS(Input, VFIntermediates, VertexParameters);
		#endif

		#if INTERPOLATE_POSITION
			OutParameters.PixelPosition = WorldPos.xyz;
		#endif

		LayerIndex = bUseGpuSceneInstancing ? VertexFactoryGetViewIndex(VFIntermediates) : LayerId;
		OutPosition = mul(WorldPos, PassStruct.ShadowViewProjectionMatrices[LayerIndex]);
	
	#else
		float Dummy;

		SetShadowDepthOutputs(
			PassStruct.ProjectionMatrix,
			PassStruct.ViewMatrix,
			WorldPos,
			WorldNormal,
			OutPosition,
			#if !PERSPECTIVE_CORRECT_DEPTH
				Dummy
			#else
				OutParameters.ShadowDepth,
				OutParameters.DepthBias
			#endif
			);
	
		#if INTERPOLATE_VF_ATTRIBUTES
			// Masked materials need texture coords to clip
			OutParameters.FactoryInterpolants = VertexFactoryGetInterpolantsVSToPS(Input, VFIntermediates, VertexParameters);
		#endif

		#if INTERPOLATE_POSITION
			OutParameters.PixelPosition = WorldPos.xyz;
		#endif

		#if !PERSPECTIVE_CORRECT_DEPTH && !COMPILER_SUPPORTS_EMPTY_STRUCTS
			OutParameters.Dummy = 0;
		#endif
	
	#endif

	#if VIRTUAL_SM_ENABLED
		PackedPageInfo = 0;
	
		OutVirtualSmPageClip = float4(1.0f, 1.0f, 1.0f, 1.0f);
		if (PassStruct.bRenderToVirtualShadowMap != 0)
		{
			// Get the offset from which we loaded the instance ID
			uint InstanceIdIndex = VertexFactoryGetInstanceIdLoadIndex(VFIntermediates);
			PackedPageInfo = InstanceCulling.PageInfoBuffer[InstanceIdIndex];

			FPageInfo PageInfo = UnpackPageInfo(PackedPageInfo);

			TransformToVirtualSmPage(OutPosition, OutVirtualSmPageClip, PageInfo, WorldPos.xyz);
		}
	#endif // VIRTUAL_SM_ENABLED
}

//-----------------------------------------------------------------------------------------------------------
#elif PIXELSHADER
//-----------------------------------------------------------------------------------------------------------

bool RaymarchFogVolume(
	VdbSampler DensitySampler,
	VdbRay Ray,
	FMaterialPixelParameters MaterialParameters,
	RandomSequence RandSequence,
	float4x4 LocalToWorld,
	float4x4 WorldToLocal,
	float4 SvPosition,
	out float3 FirstIntersection)
{
	float MinDistLocal = 0.0;
	float3 Transmittance = 0.0;
	pnanovdb_vec3_t iPos = 0.0;

#if LEVEL_SET
	if (!TRANSLUCENT_LEVEL_SET)
	{
		ZeroCrossingHit HitResults;
		if (!GetNextIntersection(DensitySampler, Ray, HitResults))
		{
			Transmittance = 1.0;
		}
		iPos = pnanovdb_coord_to_vec3(HitResults.ijk_hit); // index/vdb space hit position
	}
	else
#endif
	{
		Transmittance = GetTransmittance(
			Ray.Origin, Ray.Direction,
			DensitySampler,
			2.0 * SHADOW_STEP_SIZE_MULT,
			LocalToWorld, SHADOW_THRESHOLD, RandSequence, MinDistLocal, MaterialParameters);
		Transmittance = Average(Transmittance);
		iPos = pnanovdb_hdda_ray_start(Ray.Origin, MinDistLocal, Ray.Direction);
	}

	float3 WorldPos = IndexToWorldPosition(iPos, LocalToWorld, DensitySampler.GridBuffer, DensitySampler.Grid);
	FirstIntersection = LWCToFloat(LWCAdd(WorldPos, PrimaryView.PreViewTranslation));

	return all(Transmittance < SHADOW_THRESHOLD);
}


bool GetFurtherVdbValue(FShadowDepthVSToPS Inputs, float4 SvPosition, out float3 LastIntersection)
{
	VdbSampler DensitySampler = InitVdbSampler(DensityVdbBuffer);

	FMaterialPixelParameters MaterialParameters = GetMaterialPixelParameters(Inputs.FactoryInterpolants, SvPosition);

	uint PrimId = VertexFactoryGetPrimitiveId(Inputs.FactoryInterpolants);
	float4x4 WorldToLocal = LWCHackToFloat(GetPrimitiveData(PrimId).WorldToLocal);
	float4x4 LocalToWorld = LWCHackToFloat(GetPrimitiveData(PrimId).LocalToWorld);

	float DeviceZ = FarDepthValue; // let depth write test do its job
#if HAS_INVERTED_Z_BUFFER
	DeviceZ = max(DeviceZ, 0.000000000001); // either no Z value, or too far to even consider
#endif
	LastIntersection = 0.0; // Translated world space

	RandomSequence RandSequence;
	RandomSequence_Initialize(RandSequence, SvPosition.xy, 0, ResolvedView.StateFrameIndex + ResolvedView.Random, 1);
	
	VdbRay Ray = PrepareShadowRayFromPixel(DensitySampler.GridBuffer, DensitySampler.Grid, SvPosition, WorldToLocal, DeviceZ, false);

	return RaymarchFogVolume(	DensitySampler,
								Ray,
								MaterialParameters, RandSequence,
								LocalToWorld, WorldToLocal, SvPosition, LastIntersection);
}


void MainPS(
	FShadowDepthVSToPS Inputs,
#if VIRTUAL_SM_ENABLED
	nointerpolation uint PackedPageInfo : TEXCOORD8,
#endif
	in float4 SvPosition : SV_Position // after all interpolators
#if PERSPECTIVE_CORRECT_DEPTH || COMPILER_METAL || INTERPOLATE_VF_ATTRIBUTES
	,out float OutDepth : SV_DEPTH
#endif
	)
{
	ResolvedView = ResolveView();

#if INTERPOLATE_VF_ATTRIBUTES
	
	float3 LastIntersection = 0.0;
	bool Valid = GetFurtherVdbValue(Inputs, SvPosition, LastIntersection);
	
	if (!Valid) discard;
	
	#if 1
		float Dummy;
		float4 OutPosition;
		float OutDepthZ;
		float OutDepthBias;
		float4 WorldPos = float4(LastIntersection.xyz, 1.0);
	
		SetShadowDepthOutputs(
			PassStruct.ProjectionMatrix, // actually TranslatedWorldToClipOuterMatrix
			PassStruct.ViewMatrix, // actually TranslatedWorldToView
			WorldPos,
			0.0,
			OutPosition,
			OutDepthZ
			#if PERSPECTIVE_CORRECT_DEPTH
				, OutDepthBias
			#endif
			);
		OutDepth = OutPosition.z;
	#else
		float4 ClipPos = mul(float4(LastIntersection.xyz, 1.0), PassStruct.ProjectionMatrix);
		float SceneDepth = ClipPos.z / ClipPos.w;
		OutDepth = SceneDepth;
	#endif
	
#else
	ClipLODTransition(SvPosition.xy);
#endif

#if PERSPECTIVE_CORRECT_DEPTH
	const float InvMaxSubjectDepth = PassStruct.ShadowParams.w;
	Inputs.ShadowDepth = 1 - Inputs.ShadowDepth * InvMaxSubjectDepth;
	Inputs.ShadowDepth += Inputs.DepthBias;

	OutDepth = saturate(Inputs.ShadowDepth);
#elif COMPILER_METAL
	// Metal fragment shader must not be empty,
	// so output depth value explicitly if this shader permuation was not discarded
	OutDepth = SvPosition.z;
#endif

#if ENABLE_NON_NANITE_VSM && VIRTUAL_TEXTURE_TARGET
	uint2 vAddress = (uint2)SvPosition.xy;
	float DeviceZ = SvPosition.z;

	FPageInfo PageInfo = UnpackPageInfo( PackedPageInfo );
	FNaniteView NaniteView = UnpackNaniteView( PassStruct.PackedNaniteViews[ PageInfo.ViewId ] );

	FShadowPhysicalPage Page = ShadowDecodePageTable( PassStruct.VirtualSmPageTable[ CalcPageOffset( NaniteView.TargetLayerIndex, NaniteView.TargetMipLevel, vAddress >> VSM_LOG2_PAGE_SIZE ) ] );

	if( Page.bThisLODValid )
	{
		uint2 pAddress = Page.PhysicalAddress * VSM_PAGE_SIZE + (vAddress & VSM_PAGE_SIZE_MASK);
		// If requested, render to the static page
		const int ArrayIndex = PageInfo.bStaticPage ? GetVirtualShadowMapStaticArrayIndex() : 0;
		InterlockedMax( PassStruct.OutDepthBufferArray[ uint3( pAddress, ArrayIndex ) ], asuint( DeviceZ ) );
	}
#endif
}

#endif